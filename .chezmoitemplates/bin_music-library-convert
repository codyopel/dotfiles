#!/usr/bin/env elvish
# vim: ft=elvish

# Trancodes all audio files in a source directory to a target directory.
# Assumes a directory structure of <first letter/number>/<artist>/<album>/<track>

use github.com/chlorm/elvish-stl/list
use github.com/chlorm/elvish-stl/os
use github.com/chlorm/elvish-stl/path
use github.com/chlorm/elvish-stl/re
use github.com/chlorm/elvish-stl/str
use github.com/chlorm/elvish-util-wrappers/ffmpeg


var SOURCE_PATH = $args[0]
var TARGET_PATH = $args[1]


fn output-filename {|file|
    var base = (path:basename $file)
    re:replace (path:ext $base)'$' '.ogg' $base
}

fn transcode-audio-file {|input output|
    var ebur128Measure = (ffmpeg:filter-ebur128-measure $input 0)
    var ebur128 = (ffmpeg:filter-ebur128 $ebur128Measure)
    # Silent audio files cannot be measured
    var ebur128Enable = $true
    if (==s $ebur128Measure['input_i'] '-inf') {
        set ebur128Enable = $false
    }
    var args = [
        '-n'
        #'-v' 'trace'
        '-hide_banner'
        '-fflags' '-autobsf+bitexact'
        '-i' $input
        # Strip replaygain side data using volume filter
        '-filter_complex' '[0:a:0]volume=replaygain=drop'(if $ebur128Enable { put '[srg];[srg]'$ebur128 })'[out]'
        '-map' '[out]'
        (ffmpeg:default-resampler-flags)
        '-map_metadata' 0
        # Strip replaygain metadata
        '-metadata' 'REPLAYGAIN_ALBUM_GAIN='
        '-metadata' 'REPLAYGAIN_ALBUM_PEAK='
        '-metadata' 'REPLAYGAIN_TRACK_GAIN='
        '-metadata' 'REPLAYGAIN_TRACK_PEAK='
        '-threads' 1
        '-vn'
        '-c:0' 'libopus'
        '-b:0' '128k'
        '-vbr' 'on'
        '-compression_level' 10
        '-frame_duration' 20
        $output

    ]
    try {
        echo 'ffmpeg' $@args >&2
        e:ffmpeg $@args
    } catch e {
        if (os:exists $output) {
            os:remove $output
        }
        echo 'failed at: ffmpeg '$@args >&2
        fail $e
    }
}

fn transcode-image-file {|input output|
    e:magick 'convert' ^
        '-size' '500x500' ^
        $input ^
        '-resize' '500x500^' ^
        $output

}

fn is-audio-file {|file|
    var validExtensions = [
        '.flac'
        '.ogg'
        '.m4a'
        '.mp3'
        '.wv'
    ]
    if (list:has $validExtensions (str:to-lower (path:ext $file))) {
        put $true
        return
    }
    put $false
}

fn is-image-file {|file|
    var validExtensions = [
        '.jpg'
        '.jpeg'
        '.png'
        '.tiff'
    ]
    if (list:has $validExtensions (str:to-lower (path:ext $file))) {
        put $true
        return
    }
    put $false
}

do-image-file {|source target filename|
    var imgSource = $nil
    for i [ 'jpg' 'jpeg' 'png' 'tiff' ] {
        var img = (path:join $source $filename'.'$i)
        if (os:exists $img) {
            set imgSource = $img
            break
        }
    }

    if (eq $imgSource $nil) {
        return
    }

    var imgTarget = (path:join $target $filename'.jpg')
    if (not (os:exists $imgTarget)) {
        os:makedirs $target
        transcode-imafe-file $imgSource $imgTarget
    }
}

fn get-dirs {|path|
    put (path:scandir $path)['dirs']
}

fn get-files {|path|
    put (path:scandir $path)['files']
}

fn main {
    for root (get-dirs $SOURCE_PATH) {
        var rootDirSource = (path:join $SOURCE_PATH $root)
        var rootDirTarget = (path:join $TARGET_PATH $root)
        for artist (get-dirs $rootDirSource) {
            echo '>'$artist >&2
            var artistDirSource = (path:join $rootDirSource $artist)
            var artistDirTarget = (path:join $rootDirTarget $artist)
            do-image-file $artistDirSource $artistDirTarget 'artist'
            for album (get-dirs $artistDirSource) {
                echo '>>'$album >&2
                var albumDirSource = (path:join $artistDirSource $album)
                var albumDirTarget = (path:join $artistDirTarget $album)
                do-image-file $albumDirSource $albumDirTarget 'Folder'
               for track (get-files $albumDirSource) {
                    if (not (is-audio-file $source)) {
                        return
                    }
                    if (not (os:exists $target)) {
                        put [ $source $target ]
                    }
                }

            }
        }
    } | peach &num-workers=10 {|x|
        echo "Transcoding: "$x[1] >&2
        transcode-audio-file $x[0] $x[1]
    }
}

main


